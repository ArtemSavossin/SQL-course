## Домашние задания по курсу SQL:

-   [ДЗ1](#HW1)
-   [ДЗ2](#HW2)
-   [ДЗ3](#HW3)
-   [ДЗ4](#HW4)
-   [ДЗ5](#HW5)
-   [ДЗ6](#HW6)
-   [ДЗ7](#HW7)
-   [ДЗ8](#HW8)
-   [ДЗ9](#HW9)

### <a name="HW1"></a> [ДЗ 1]
#### Описание предметной области и планирование БД

![ERD](./ERD.jpg)
### <a name="HW2"></a> [ДЗ 2]
#### №1
>Попробуйте ввести в таблицу aircrafts строку с таким значением атрибута
«Код самолета» (aircraft_code), которое вы уже вводили

Можно заметить, что в таблице `aircrafts` атрибут `aircraft_code` является `PRIMARY_KEY`, а мы знаем, что при реализации ключа таблицы создается индекс, главное свойтсво которого -- уникальность. 
#### №2
>Предложение ORDER BY команды SELECT позволяет отсортировать данные при
выводе. По умолчанию сортировка выполняется по возрастанию значений атрибута, указанного в этом предложении. Но можно упорядочить строки и по
убыванию значения атрибута. Для этого нужно после имени атрибута в предложении ORDER BY добавить ключевое слово DESC (это сокращение от слова
descendant — убывающий порядок). Самостоятельно напишите команду для выборки всех строк из таблицы aircrafts, чтобы строки были упорядочены по убыванию значения атрибута «Максимальная дальность полета, км» (range).

`
SELECT * FROM aircrafts ORDER BY range DESC;
`
Вывод:
```
 aircraft_code |        model        | range 
---------------+---------------------+-------
 773           | Boeing 777-300      | 11100
 763           | Boeing 767-300      |  7900
 319           | Airbus A319-100     |  6700
 320           | Airbus A320-200     |  5700
 321           | Airbus A321-200     |  5600
 733           | Boeing 737-300      |  4200
 SU9           | Sukhoi SuperJet-100 |  3000
 CR2           | Bombardier CRJ-200  |  2700
 CN1           | Cessna 208 Caravan  |  1200
```
#### №3
> Команда UPDATE позволяет в процессе обновления выполнять арифметические
действия над значениями, находящимися в строках таблицы. Представим себе,
что двигатели самолета Sukhoi SuperJet стали в два раза экономичнее, вследствие чего дальность полета этого лайнера возросла ровно в два раза. Команда
UPDATE позволяет увеличить значение атрибута range в строке, хранящей информацию об этом самолете, даже не выполняя предварительно выборку с целью выяснения текущего значения этого атрибута. При присваивании нового значения атрибуту range можно справа от знака «=» написать не только числовую константу, но и целое выражение. В нашем случае оно будет простым:
range = range * 2. Самостоятельно напишите команду UPDATE полностью, при
этом не забудьте, что увеличить дальность полета нужно только у одной модели — Sukhoi SuperJet, поэтому необходимо использовать условие WHERE. Затем
с помощью команды SELECT проверьте полученный результат.

`UPDATE aircrafts
    SET range = range * 2
    WHERE model = ’Sukhoi SuperJet-100’;`
    
`SELECT * FROM aircrafts
    ORDER BY range DESC;`
    
```
 aircraft_code |        model        | range 
---------------+---------------------+-------
 773           | Boeing 777-300      | 11100
 763           | Boeing 767-300      |  7900
 319           | Airbus A319-100     |  6700
 SU9           | Sukhoi SuperJet-100 |  6000
 320           | Airbus A320-200     |  5700
 321           | Airbus A321-200     |  5600
 733           | Boeing 737-300      |  4200
 CR2           | Bombardier CRJ-200  |  2700
 CN1           | Cessna 208 Caravan  |  1200
```
#### №4
> Если в предложении WHERE команды DELETE вы укажете логически и синтаксически корректное условие, но строк, удовлетворяющих этому условию, в таблице не окажется, то в ответ СУБД выведет сообщение
DELETE 0
Такая ситуация не является ошибкой или сбоем в работе СУБД. Например, если после удаления какой-то строки вы повторно попытаетесь удалить ее же, то
получите именно такое сообщение.
Самостоятельно смоделируйте описанную ситуацию, подобрав условие, которому гарантированно не соответствует ни одна строка в таблице «Самолеты»
(aircrafts).

INPUT : `DELETE FROM aircrafts
        WHERE range > 100000000;`
        
OUTPUT : `DELETE 0`

`SELECT * FROM aircrafts
    ORDER BY range DESC;`
    
Возвращает 

```
 aircraft_code |        model        | range 
---------------+---------------------+-------
 773           | Boeing 777-300      | 11100
 763           | Boeing 767-300      |  7900
 319           | Airbus A319-100     |  6700
 SU9           | Sukhoi SuperJet-100 |  6000
 320           | Airbus A320-200     |  5700
 321           | Airbus A321-200     |  5600
 733           | Boeing 737-300      |  4200
 CR2           | Bombardier CRJ-200  |  2700
 CN1           | Cessna 208 Caravan  |  1200
```
Такую же таблицу без изменений.

### <a name="HW3"></a> [ДЗ 3]
#### №2
>Предположим, что возникла необходимость хранить в одном столбце таблицы
данные, представленные с различной точностью. Это могут быть, например,
результаты физических измерений разнородных показателей или различные
медицинские показатели здоровья пациентов (результаты анализов). В таком
случае можно использовать тип numeric без указания масштаба и точности.
Команда для создания таблицы может быть, например, такой:
` CREATE TABLE test_numeric ( measurement numeric, description text ); `
Если у вас в базе данных уже есть таблица с таким же именем, то можно предварительно ее удалить с помощью команды
`DROP TABLE test_numeric;`
Вставьте в таблицу несколько строк:
`INSERT INTO test_numeric VALUES ( 1234567890.0987654321, 'Точность 20 знаков, масштаб 10 знаков' );`
`INSERT INTO test_numeric VALUES ( 1.5, 'Точность 2 знака, масштаб 1 знак' );`
`INSERT INTO test_numeric VALUES ( 0.12345678901234567890, 'Точность 21 знак, масштаб 20 знаков' );`
`INSERT INTO test_numeric VALUES ( 1234567890, 'Точность 10 знаков, масштаб 0 знаков (целое число)' );`
Теперь сделайте выборку из таблицы и посмотрите, что все эти разнообразные
значения сохранены именно в том виде, как вы их вводили.

` SELECT * from test_numeric`
Вывод команды:
```
      measurement       |                    description                     
------------------------+----------------------------------------------------
  1234567890.0987654321 | Точность 20 знаков, масштаб 10 знаков
                    1.5 | Точность 2 знака, масштаб 1 знак
 0.12345678901234567890 | Точность 21 знак, масштаб 20 знаков
             1234567890 | Точность 10 знаков, масштаб 0 знаков (целое число)
```

#### №4
>При работе с числами типов real и double precision нужно помнить, что
сравнение двух чисел с плавающей точкой на предмет равенства их значений
может привести к неожиданным результатам.

Задания из примера отработали корректно, попробуем запросы на верхней границе:

`SELECT '10e37'::real > '11e37'::real;`

OUTPUT:
```
 ?column? 
----------
 f
(1 row)
```

`SELECT '1e308'::double precision > '12e307'::double precision;`

OUTPUT:
```
 ?column? 
----------
 f
(1 row)
```

На верхних границах все тоже работает корректно.
#### №8
Для начала создадим таблицу по заданию 8
`CREATE TABLE test_serial
( id serial PRIMARY KEY,
name text
);`

Далее вставим значение: 
`INSERT INTO test_serial ( name ) VALUES ( 'Вишневая' );`
```
 id |   name   
----+----------
  1 | Вишневая
```

Явно зададим значение столбца id:
`INSERT INTO test_serial ( id, name ) VALUES ( 2, 'Прохладная' );`

```
 id |    name    
----+------------
  1 | Вишневая
  2 | Прохладная
```

При выполнении этой команды СУБД выдаст сообщение об ошибке. Почему?
`INSERT INTO test_serial ( name ) VALUES ( 'Грушевая' );`
Происходит ошибка, так как внутренний счетчик `serial` при вставке Грушевой встал на значение 2, которое уже есть в таблице, из-за чего сработало ограничение уникальности `id`. При последующем запросе вставка работает, так как счетчик поднялся до значния выше.

`INSERT INTO test_serial ( name ) VALUES ( 'Грушевая' );`

```
 id |    name    
----+------------
  1 | Вишневая
  2 | Прохладная
  3 | Грушевая
```

Добавим еще одну строку.
`INSERT INTO test_serial ( name ) VALUES ( 'Зеленая' );`

А теперь удалим ее же.
`DELETE FROM test_serial WHERE id = 4;`

Добавим последнюю строку.
`INSERT INTO test_serial ( name ) VALUES ( 'Луговая' );`

Теперь сделаем выборку.
`SELECT * FROM test_serial;`

```
 id |    name    
----+------------
  1 | Вишневая
  2 | Прохладная
  3 | Грушевая
  5 | Луговая
```
Вы увидите, что в нумерации образовалась «дыра». Это из-за того, что при формировании нового значения из последовательности поиск максимального значения, уже имеющегося в столбце, не выполняется.

#### №12
После выполнения `SET datestyle TO 'MDY';` команда `SELECT '18-05-2016'::date;`
будет вызывать ошибку, так как мы поставили формат ввода, где месяц стоит на первом месте.
```
ERROR:  date/time field value out of range: "18-05-2016"
LINE 1: SELECT '18-05-2016'::date;
               ^
HINT:  Perhaps you need a different "datestyle" setting.
```

Теперь посмотрим на работу timestamp:

`SELECT '18-05-2016'::timestamp;`

Получаем аналогичное поведение:
```
ERROR:  date/time field value out of range: "18-05-2016"
LINE 1: SELECT '18-05-2016'::timestamp;
               ^
HINT:  Perhaps you need a different "datestyle" setting.
```

При смене параметров даты, все заработает ок:
`SET datestyle TO 'Postgres, DMY';`

Все заработает, как и описано в задании. 

`SELECT '18-05-2016'::timestamp;`

```
        timestamp         
--------------------------
 Wed 18 May 00:00:00 2016
(1 row)
```

#### №15
`SELECT to_char( current_timestamp, 'mi:ss' );`
Должен вывести секунды, и, скорее всего, минуты или миллисекунды. 

```
 to_char 
---------
 22:51
(1 row)
```

Вывод - минуты и секунды.

`SELECT to_char( current_timestamp, 'dd' );` 
Введет дни.
```
 to_char 
---------
 20
(1 row)
```

`SELECT to_char( current_timestamp, 'yyyy-mm-dd' );`
Данная команда должна вывести текущую дату в привчном формате.

```
  to_char   
------------
 2021-12-20
(1 row)
```

Эксперимент:
`SELECT to_char( current_timestamp, 'yyyy-mm-dd mi:hh:ss' );`

```
       to_char       
---------------------
 2021-12-20 26:07:09
(1 row)
```

#### №21
По запросу `SELECT ( '2016-01-31'::date + '1 mon'::interval ) AS new_date;`
Думаю, что получим последний день второго месяца -- так как мы прибавляем интервал ровно в 1 месяц. 
```
         new_date         
--------------------------
 Mon 29 Feb 00:00:00 2016
(1 row)
```

В команде `SELECT ( '2016-02-29'::date + '1 mon'::interval ) AS new_date;`
Все не так очевидно - к последнему дню февраля мы прибавляем интервал в 1 месяц - должно получиться либо последний день марта, либо какое-то из последних чисел месяца (потому что в феврале мало дней и непонятно, как распределится интервал).
```
         new_date         
--------------------------
 Tue 29 Mar 00:00:00 2016
(1 row)
```

#### №30
Ожидаю, что все команды, в которых нет прямого приведения переменных к нужному типу, или переменные не в кавычках, будут падать с ошибкой, например: 

`INSERT INTO test_bool VALUES ( 1, 'true' );`
Здесь 1 -- явно не типа `boolean`, и не указывается кастование его в этот тип, поэтому поймаем ошибку.

```
ERROR:  column "a" is of type boolean but expression is of type integer
LINE 1: INSERT INTO test_bool VALUES ( 1, 'true' );
                                       ^
HINT:  You will need to rewrite or cast the expression.
```

Так же есть запрос `INSERT INTO test_bool VALUES ( 't', truth );`

Где `truth` -- это какая-то необъявленная нигде переменная, на которую будет ругаться программа.
```
ERROR:  column "truth" does not exist
LINE 1: INSERT INTO test_bool VALUES ( 't', truth );
```

#### №33
Создаем таблицу:
`CREATE TABLE pilots ( pilot_name text, schedule integer[], meal text[][]);`

Вставляем значения из примера, только с двумерным массивом
```
 INSERT INTO pilots
    VALUES ('Ivan', '{ 1, 3, 5, 6, 7 }'::integer[],
             '{ { "сосиска", "макароны", "кофе" },
                { "сосиска", "макароны", "кофе" },
                { "сосиска", "макароны", "кофе" },
                { "сосиска", "макароны", "кофе" } }'::text[][]
           ),
           ( 'Petr', '{ 1, 2, 5, 7 }'::integer [],
             '{ { "котлета", "каша", "кофе" },
                { "котлета", "каша", "кофе" },
                { "котлета", "каша", "кофе" },
                { "котлета", "каша", "кофе" } }'::text[][]
           ),
           ( 'Pavel', '{ 2, 5 }'::integer[],
             '{ { "сосиска", "каша", "кофе" },
                { "сосиска", "каша", "кофе" },
                { "сосиска", "каша", "кофе" },
                { "сосиска", "каша", "кофе" } }'::text[][]
           ),
           ( 'Boris', '{ 3, 5, 6}'::integer[],
             '{ { "котлета", "каша", "чай" },
                { "котлета", "каша", "чай" },
                { "котлета", "каша", "чай" },
                { "котлета", "каша", "чай" } }'::text[][]
       );
```

Рубрика эксперименты:

`SELECT * FROM pilots;`

```
 pilot_name |  schedule   |                                               meal             
                                   
------------+-------------+----------------------------------------------------------------
-----------------------------------
 Ivan       | {1,3,5,6,7} | {{сосиска,макароны,кофе},{сосиска,макароны,кофе},{сосиска,макар
оны,кофе},{сосиска,макароны,кофе}}
 Petr       | {1,2,5,7}   | {{котлета,каша,кофе},{котлета,каша,кофе},{котлета,каша,кофе},{к
отлета,каша,кофе}}
 Pavel      | {2,5}       | {{сосиска,каша,кофе},{сосиска,каша,кофе},{сосиска,каша,кофе},{с
осиска,каша,кофе}}
 Boris      | {3,5,6}     | {{котлета,каша,чай},{котлета,каша,чай},{котлета,каша,чай},{котл
ета,каша,чай}}
```

`SELECT pilot_name FROM pilots
WHERE meal[1][1:3] && '{"сосиска"}'::text[];`

```
 pilot_name 
------------
 Ivan
 Pavel
(2 rows)
```

`UPDATE pilots
    SET meal[1][3] = 'пирожок'
    WHERE pilot_name = 'Pavel';`
    
`SELECT meal FROM pilots WHERE pilot_name = 'Pavel';`

```
                                         meal                                         
--------------------------------------------------------------------------------------
 {{сосиска,каша,пирожок},{сосиска,каша,кофе},{сосиска,каша,кофе},{сосиска,каша,кофе}}
```

#### №35
Примеры изученных запросов
`SELECT '{"sports" : "хоккей"}'::jsonb->'sports';`

```
 ?column? 
----------
 "хоккей"
```

`SELECT '{"sports" : "хоккей"}'::jsonb->>'sports';`

```
 ?column? 
----------
 хоккей
(1 row)
```

`SELECT '{"a" : {"b" : "c"}}'::jsonb#>'{a, b}';`

```
 ?column? 
----------
 "c"
(1 row)
```

`SELECT '{"a":1, "b":2}'::jsonb @> '{"b":2}'::jsonb;`

```
 ?column? 
----------
 t
(1 row)
```

`SELECT '{"a":1}'::jsonb <@ '{"a":1, "b":2}'::jsonb;`

```
 ?column? 
----------
 t
(1 row)
```

`SELECT '{"a":1, "b":2}'::jsonb ?& array['a', 'b'];`

```
 ?column? 
----------
 t
(1 row)
```
### <a name="HW4"></a> [ДЗ 4]

### <a name="HW5"></a> [ДЗ 5]
### <a name="HW6"></a> [ДЗ 6]
### <a name="HW7"></a> [ДЗ 7]
### <a name="HW8"></a> [ДЗ 8]
### <a name="HW9"></a> [ДЗ 9]
